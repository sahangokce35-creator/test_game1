<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Neon Starfield Battle</title>
<style>
  html,body{margin:0;background:#000;overflow:hidden;height:100%;}
  /* Canvas fills the screen (we still set the internal buffer in JS) */
  canvas{
    position:fixed;inset:0;width:100vw;height:100vh;
    background:radial-gradient(circle at 50% 40%, #08122a 0%, #000 70%);
    touch-action:none; /* stop double-tap zoom */
  }

  /* Floating mobile controls (auto-fade) */
  #leftPad,#rightPad{
    position:fixed;bottom:calc(10% + env(safe-area-inset-bottom, 0px));
    width:140px;height:140px;border-radius:50%;
    border:2px solid rgba(255,255,255,.2);
    background:radial-gradient(circle,rgba(255,255,255,.08),rgba(255,255,255,.02));
    pointer-events:auto;transition:opacity .6s;opacity:.6;backdrop-filter:blur(2px);
  }
  #leftPad{left:5%;}
  #rightPad{right:5%;display:grid;place-items:center;}
  #rightPad::after{content:'FIRE';color:#ffdd55;font-weight:900;font-family:monospace;font-size:14px;}

  @media (max-width:600px){
    #leftPad,#rightPad{width:110px;height:110px;}
  }
</style>
</head>
<body>
<audio id="theme" src="https://cdn.pixabay.com/download/audio/2023/04/15/audio_59e3e9a02c.mp3?filename=star-wars-theme-epic-cover.mp3" preload="auto" loop></audio>

<canvas id="game"></canvas>
<div id="leftPad"></div>
<div id="rightPad"></div>

<script>
/* ============ Canvas + Responsive sizing ============ */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let W = 900, H = 600;

function resizeCanvas(){
  const DPR = Math.min(2, window.devicePixelRatio || 1); // cap for perf
  const cssW = window.innerWidth;
  const cssH = window.innerHeight;

  // CSS size (visual)
  canvas.style.width  = cssW + "px";
  canvas.style.height = cssH + "px";

  // Internal bitmap for crisp drawing
  canvas.width  = Math.floor(cssW * DPR);
  canvas.height = Math.floor(cssH * DPR);

  // Draw in CSS pixels from now on
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  W = cssW; H = cssH;

  // keep player on screen; regen stars scaled to area
  player.y = Math.min(player.y, H - player.r);
  makeStars(Math.max(160, Math.round((W * H) / 4500)));
  crawlY = H * 0.9;
}
window.addEventListener('resize', resizeCanvas, {passive:true});

/* ============ State ============ */
const music = document.getElementById("theme");
const keys = {};
let stars = [], bullets = [], enemies = [];
let score = 0, level = 1;
let state = "crawl";  // crawl | intro | playing | gameover
let crawlY = 540;
const hiKey = "neon-starfield-hi";

const player = { x: 120, y: 300, r: 14, speed: 5, cd: 0, alive: true };

let audioCtx, audioUnlocked = false;
function sfx(freq=440, type="square", duration=0.1, volume=0.05){
  try {
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = volume;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + duration);
  } catch(e){}
}

/* ============ Stars ============ */
function makeStars(n=220){
  stars = [];
  for (let i=0;i<n;i++){
    stars.push({
      x: Math.random() * W,
      y: Math.random() * H,
      size: Math.random() * 2,
      speed: Math.random() * 1.5 + 0.4
    });
  }
}
function drawStars(dt=0.016){
  ctx.fillStyle = "#fff";
  for (const s of stars){
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
    ctx.fill();
    s.x -= s.speed * (state==="crawl" ? 0.5 : 1) * (dt*60/60);
    if (s.x < 0){ s.x = W; s.y = Math.random()*H; }
  }
}

/* ============ Mobile pads (fade out) ============ */
let touchY=null, firePressed=false, fadeTimer=null;
const leftPad = document.getElementById("leftPad");
const rightPad = document.getElementById("rightPad");
function showPads(show=true){ leftPad.style.opacity = rightPad.style.opacity = show ? .6 : 0; }
function resetFade(){ showPads(true); clearTimeout(fadeTimer); fadeTimer = setTimeout(()=>showPads(false), 3000); }
leftPad.addEventListener("touchstart", e=>{touchY=e.touches[0].clientY; resetFade();}, {passive:true});
leftPad.addEventListener("touchmove", e=>{
  const y=e.touches[0].clientY;
  keys["ArrowUp"] = (y < touchY-10);
  keys["ArrowDown"] = (y > touchY+10);
}, {passive:true});
leftPad.addEventListener("touchend", ()=>{ keys["ArrowUp"]=keys["ArrowDown"]=false; touchY=null; }, {passive:true});
rightPad.addEventListener("touchstart", ()=>{ firePressed=true; keys[" "]=true; resetFade(); }, {passive:true});
rightPad.addEventListener("touchend", ()=>{ firePressed=false; keys[" "]=false; }, {passive:true});

/* ============ Drawing helpers ============ */
function drawShip(x,y){
  ctx.save(); ctx.translate(x,y);
  ctx.beginPath();
  ctx.moveTo(20,0); ctx.lineTo(-12,-10); ctx.lineTo(-8,-4);
  ctx.lineTo(-8,4);  ctx.lineTo(-12,10); ctx.closePath();
  const g = ctx.createLinearGradient(-12,-10,20,0);
  g.addColorStop(0,"#ffe761"); g.addColorStop(1,"#f7c200");
  ctx.fillStyle=g; ctx.shadowColor="#ffde59"; ctx.shadowBlur=10; ctx.fill(); ctx.shadowBlur=0;
  // thruster
  ctx.beginPath(); ctx.moveTo(-12,-5); ctx.lineTo(-20,0); ctx.lineTo(-12,5); ctx.closePath();
  ctx.fillStyle="rgba(255,200,80,.7)"; ctx.fill();
  ctx.restore();
}
function drawEnemy(e){
  ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
  ctx.fillStyle="#ff4b4b"; ctx.shadowColor="#ff4b4b"; ctx.shadowBlur=8; ctx.fill(); ctx.shadowBlur=0;
}
function drawBullet(b){
  ctx.fillStyle="#ffe761"; ctx.fillRect(b.x,b.y,b.w,b.h);
}
function drawHud(){
  ctx.fillStyle="#ffe761"; ctx.font="18px monospace";
  ctx.fillText("Score: "+score, 15, 25);
  ctx.fillText("Level: "+level, 15, 45);
  ctx.fillText("HI: "+(localStorage.getItem(hiKey)||0), 15, 65);
}

/* ============ Star Wars crawl (responsive) ============ */
function drawCrawl(){
  drawStars();
  const txt = [
    "WELCOME NEW JEDI ðŸš€", "",
    "NEON STARFIELD BATTLE", "",
    "A long time ago in a galaxy far, far away...", "",
    "Press ENTER or TAP to begin"
  ];
  const tilt = (W < 700) ? -0.12 : -0.20;
  const stretch = (W < 700) ? 1.3 : 1.5;

  ctx.save();
  ctx.translate(W/2, crawlY);
  ctx.rotate(tilt);
  ctx.scale(1, stretch);
  ctx.fillStyle = "#ffe761";
  ctx.textAlign = "center";
  ctx.font = (W < 700 ? "22px" : "28px") + " 'Courier New', monospace";
  for (let i=0;i<txt.length;i++) ctx.fillText(txt[i], 0, i*40);
  ctx.restore();

  crawlY -= (W < 700 ? 0.38 : 0.5);
  if (crawlY < -300) state = "intro";
}

/* ============ Flow ============ */
function startGame(){
  if (!audioUnlocked){
    try{
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      audioCtx.resume();
      music.volume = 0.3; music.play();
      audioUnlocked = true;
    }catch(e){}
  }
  sfx(520,"triangle",.12,.08);
  state="playing"; score=0; level=1; bullets.length=enemies.length=0; player.alive=true;
}
function restart(){
  try{ music.pause(); music.currentTime=0; }catch(e){}
  state="crawl"; crawlY = H * 0.9; makeStars(Math.max(160, Math.round((W*H)/4500)));
}

/* ============ Update ============ */
function update(dt){
  if (state!=="playing") return;

  if (keys.ArrowUp || keys.w) player.y -= player.speed;
  if (keys.ArrowDown || keys.s) player.y += player.speed;
  player.y = Math.max(player.r, Math.min(H - player.r, player.y));

  player.cd -= dt*60;
  if ((keys[" "] || firePressed) && player.cd <= 0){
    bullets.push({x:player.x+15, y:player.y-2, w:10, h:4, vx:10});
    sfx(600,"sawtooth",.05,.07);
    player.cd = 12;
  }

  for (const b of bullets) b.x += b.vx;
  bullets = bullets.filter(b => b.x < W + 20);

  // progressive spawn/speed
  if (Math.random() < 0.015 + level*0.004){
    enemies.push({x: W + 20, y: Math.random()*H, r:16, vx: 3 + level*0.35});
  }
  for (const e of enemies) e.x -= e.vx;
  enemies = enemies.filter(e => e.x > -30);

  // bullet collisions
  for (let bi=bullets.length-1; bi>=0; bi--){
    const b = bullets[bi];
    for (let ei=enemies.length-1; ei>=0; ei--){
      const e = enemies[ei];
      if (b.x < e.x + e.r && b.x + b.w > e.x - e.r && b.y < e.y + e.r && b.y + b.h > e.y - e.r){
        bullets.splice(bi,1);
        enemies.splice(ei,1);
        score += 100; sfx(150,"square",.18,.08);
        if (score % 1000 === 0) level++;
        break;
      }
    }
  }

  // crash â†’ gameover
  for (const e of enemies){
    if (Math.hypot(e.x - player.x, e.y - player.y) < e.r + player.r){
      sfx(100,"sawtooth",.3,.1);
      player.alive=false; state="gameover";
      const hi = Math.max(score, +(localStorage.getItem(hiKey)||0));
      localStorage.setItem(hiKey, hi);
      break;
    }
  }
}

/* ============ Draw ============ */
function draw(dt){
  ctx.clearRect(0,0,W,H);

  if (state === "crawl"){ drawCrawl(); return; }

  drawStars(dt);
  if (player.alive) drawShip(player.x, player.y);
  for (const b of bullets) drawBullet(b);
  for (const e of enemies) drawEnemy(e);
  drawHud();

  if (state === "gameover"){
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle="#ffe761"; ctx.font="44px monospace";
    const go="GAME OVER";
    ctx.fillText(go, (W-ctx.measureText(go).width)/2, H*0.4);
    ctx.font="22px monospace";
    const sc=`Score:${score}   Level:${level}`;
    ctx.fillText(sc,(W-ctx.measureText(sc).width)/2, H*0.48);
    const hi=localStorage.getItem(hiKey)||0;
    const hiTxt=`High:${hi}`;
    ctx.fillText(hiTxt,(W-ctx.measureText(hiTxt).width)/2, H*0.54);
    const msg="Press R or Tap to Restart";
    ctx.fillText(msg,(W-ctx.measureText(msg).width)/2, H*0.60);
  }
}

/* ============ Loop ============ */
let last = performance.now();
function loop(ts){
  const dt = Math.min(0.033, (ts-last)/1000); last = ts;
  update(dt); draw(dt); requestAnimationFrame(loop);
}

/* ============ Inputs ============ */
addEventListener("keydown", e=>{
  keys[e.key]=true;
  if ((state==="intro"||state==="crawl") && e.key==="Enter") startGame();
  if (state==="gameover" && (e.key==="r"||e.key==="R")) restart();
});
addEventListener("keyup", e=> keys[e.key]=false);
canvas.addEventListener("click", ()=>{ if(state==="intro"||state==="crawl") startGame(); else if(state==="gameover") restart(); });
canvas.addEventListener("touchstart", ()=>{ if(state==="intro"||state==="crawl") startGame(); else if(state==="gameover") restart(); resetFade(); }, {passive:true});

/* Boot */
resizeCanvas();
makeStars();
crawlY = H * 0.9;
requestAnimationFrame(loop);
</script>
</body>
</html>
